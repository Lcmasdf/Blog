---
layout: post
title: "左值与右值"
date: 2016-04-04 06:00:00
categories: language
excerpt: 老板，给我续条命!!</br>“反正你也快挂了，你的东西都是我的啦！”</br>于是，整个程序的效率提高了。
---

C++11中引入了右值引用的概念，还引入了move，forword的新语义。

到底里面暗藏什么玄机，让我们来一探究竟～

# 左值与右值

首先，左值与右值是表达式的属性。按照属性分类，每一个表达式都属于一下三种类型之一：

1. lvalue：left value,即我们所说的左值。
2. xvalue：x值，通过"右值引用"产生的对象(这点我们稍后会讲)。
3. rvalue：right value,即我们所说的右值。

区分表达式为左值表达式还是右值表达式有一个简便的方法：如果可以对表达式使用&取值，那么它就是一个左值表达式，如果不可以，那么它就是一个右值表达式。TODO：xvalue能否使用&取值。

    int a;
    int b;
    a+b;
    "1";
    ++a;
    a++;

以上表达式中，int a, int b, ++a是左值, a+b, "1", a++是右值。

函数调用根据返回值的不同可以分是lvalue，xvluae，rvalue。

    int& add (int a, int b) {
          int c = a+b;
          return c;
    }

    int&& add(int a, int b) {
          int&& d = a+b;
          return d;
    }

    int add (int a, int b) {
    	  return a+b;
    }


1. 如果函数调用返回一个左值引用，那么函数的结果就是一个lvalue。
2. 如果函数调用返回一个右值引用，那么函数的结果就是一个xvalue。
3. 如果函数调用返回一个非引用，那么函数的结果就是一个rvalue。

# 左值引用与右值引用

左值引用分为常量左值引用与非常量左值引用，即最常见的引用的用法

    int lvalue = 10;
    const int constLvalue = 10;
    
    //将非常量左值引用绑定到非常量左值上
    int& lref = lvalue;
    
    //常量左值引用可以绑定常量左值与非常量左值
    const int& cnt_lref = lvalue;
    const int& cnt_lref_cnt_lvalue = constLvalue;

在C++11之前，并没有右值引用的概念，但是右值可以被绑定到一个常量左值引用

    //将常量左值引用绑定到一个右值上
    const int& cnt_lref = 1+2;

注意，在此处因该被回收空间的右值表达式因为绑定到常量左值引用的关系，其生命周期被延长了，与常量左值引用的生命周期相同。这有什么好处呢，让我们来看下面的例子。

    class CMyString {
    public:
        CMyString() {
	    str = new char[1];
            str[0] = '\0';
        }

	//CMyString(CMyString& src) {
	//    str = new char[strlen(src.str)+1];
	//    strcpy(str, src.str);
	//}

	CMyString(const CMyString& src) {
	    str = new char[strlen(src.str)+1];
	    strcpy(str, src.str);
	}

	~CMyString() {
	    delete[] str;
	}


    private:
        char* str;
    }

    CMyString getAString() {
        CMystring aRvalueString;
	return aRvalueString;
    }

    int main () {
        CMyString(getAString());
	return 0;
    }

函数getAString返回一个右值，通过将这个右值绑定到一个常量左值引用上，减少了构造函数的开销（当然，这不是构造函数要使用引用作为参数的根本原因，根本的原因是为了防止构造函数的递归调用）。但是这样写存在一个问题，拷贝构造函数中是常引用，我们并不改变其中的值（虽然绝大多数情况下我们并不需要改变其值，但是在如auto_ptr的拷贝构造函数中，我们是需要对传入的参数做改变的)。但是const又不能够作为函数重载的依据，所以要么使用常引用拷贝构造函数，要么放弃使用右值来初始化一个类的方法。

艾玛，我都不想放弃怎么办呢？C++11中引入了右值引用的概念来解决这个问题而且右值引用可以用作函数的重载。那么我们就可以添加如下右值引用拷贝构造函数

   CMyString (CMyString&& src) {
       str = new char[strlen(src.str)+1];
       strcpy(str, src.str);
   }

现在的问题是：当我们添加了右值引用的构造函数之后，如何判断函数重载呢？C++11中按照判决的优先级列出了3条规则：

1. 常量值只能绑定到常量引用上，不能绑定到非常量引用上。
2. 左值优先绑定到左值引用上，右值优先绑定到右值引用上。
3. 非常量值优先绑定到非常量引用上。

这样我们就可以即使用右值来初始化一个类又能够在其拷贝构造函数中改变传入的参数的值。

是不是很神奇，是不是很帅，C++11是不是叼的不行！！

什么？你说这个太low！你说这没啥用？哎哎哎，别走啊，下面还有更高达上的内容呢，不信你看看进度条～


其实配合右值引用一起出现的是移动语义，两者结合在一起才是双剑合璧，天下无敌～下面我们先了解什么是移动语义，然后在看两者结合带来的好处。

# 移动语义

让我们再来看一看刚刚那个右值引用做参数的构造函数

    CMyString(CMyString&& src) {
        str = new char[strlen(src.str)+1];
        strcpy(str, src.str);
    }

我们对src.str做了一次深拷贝(deep copy)，主要原因是src是个右值，其空间被分配在栈上，而且在右值引用src生命周期结束后这部分空间要被回收。在数据量不大时，深拷贝似乎没有什么影响，但是当str巨大时，深拷贝是一个非常费时的问题。先将内存完全复制一份，然后将之前的内存再释放掉是一件多么傻的事啊！对，在C++11赋予了抢夺这块内存的权利！对没错，就是抢他丫的，不要深拷贝！那么我们的构造函数就可以这么写

    CMyString(CMyString&& src) {
       str = src.str;
    }

当然，你又不是上帝，C++11也不会允许你能抢所有的内存，所以我们要搞清楚那些内存是C++11允许我们抢夺的。

我们并不关心内存的抢夺到底是怎么实现的。我们寻找的是如何标识对象的资源是可移动的，而且这种机制需要以一种很低的资源开销与逻辑开销来实现，还要对所有的类都有效。讲到这里我想你已经发现了，在绝大多数的情况下右值包含的对象是可以安全移动的。由于右值是一个临时对象，在表达是结束之后就会被抛弃，我们刚刚好可以在其被抛弃之前，将其内存空间抢夺为己用！

注意：由于我们抢夺了别人的资源，会导致右值对象在析构时出现问题，所以我们需要手动将右值对象中的指针置为空，右值引用构造函数应该这么写

    CMyString(CMyString&& src) {
        str = src.str;
        //delete[] NULL是没有问题的
        src.str = NULL;
    }

当移动语义与右值引用结合起来，我们就可以完美的抢过来那些即将被释放的、我们需要重新申请的空间。优雅的解决了栈空间上的内存只能做丑陋的深拷贝的问题！

# move

什么？左值你也想抢！ 哎呦，小伙子（姑娘）野心挺大么～

C++11中也赋予了你抢夺左值资源的权利。对于一个左值，可以使用std::move()来将其转化为右值引用，然后就能够光明正大的使用移动语义了！

但是，对于这种行为所造成的后果需要使用者自己承担，也就是说我们必须明确move的左值是可以且应该放弃其资源的，因为抢夺一个左值的资源并不总是正确的。

下面给出一个移动语义与右值引用的经典的例子，swap函数实现在C++11前后的变化。

一个典型的swap函数如下：

    template<class T>
    void swap(T&a, T&b) {
        T tmp = a;//调用复制构造函数
        a = b;//调用operator=
        b = tmp;//调用operator=
    }

如果T是简单类型，则上述转换没有问题。但是如果T是含有指针的符合数据类型（如上文例子中的CMyString），则上述转换会调用一次复制构造函数，两次复制运算符重载（这个时候我们还不会抢！）。

虽然我们可以通过操纵CMyString的str变量来实现高效的swap。但是str是私有变量，需要通过友元函数来实现，这样需要对于所有不同的类型都重写swap函数。

在有了右值引用与移动语义之后，一切都变得不一样啦！

一个高效的swap函数如下：

    template<class T>
    void swap(T&a, T&b) {
        T tmp = std::move(var1);
        var1 = std::move(var2);
        var2 = std::move(tmp);
    }

此时，swap中三次调用了move类函数，这些函数的时间复杂度均为O(1),因此swap的整体时间复杂度也为O(1)。

# 总结

在我看来，右值引用与移动语义绝对不仅仅是语法糖，两者结合解决了C++11之前资源所有权转移这一被人所诟病的问题，是C++的一个重要革新。虽然我们不一定会为自己的每一个类都添加移动语义，但我们确实无时无刻都在享受移动语义所带来的好处。而且我们还掌握了一种重要的优化方法，在某些时候使用移动语义能够大幅度提高程序的性能，这绝对不是一个可有可无的东西！

除了移动语义，右值引用还解决了C++03中引用语法无法转发右值的问题，实现了完美转发，使得std::function能有一个优雅的实现。这部分知识我还不太了解，待我了解之后再将次内容补上～

最后说，无论是了解右值引用也好，分析移动语义也罢，甚至是深究一些语法上有的没的东西也好，在我看来都不是无意义的。许多人觉得语言东西学多了会编程language lawer，但我觉得这也没啥不好，我就是在好奇心的驱使下想多了解一下C++语言这个美丽的世界～