---
layout: post
title: "左值与右值"
date: 2016-04-04 06:00:00
categories: language
excerpt: 老板，给我续条命!!</br>于是，整个程序的效率提高了。
---

C++11中引入了右值引用的概念，还引入了move，forword的新语义。

到底里面暗藏什么玄机，让我们来一探究竟～

# 左值与右值

首先，左值与右值是表达式的属性。按照属性分类，每一个表达式都属于一下三种类型之一：

1. lvalue：left value,即我们所说的左值。
2. xvalue：x值，通过"右值引用"产生的对象(这点我们稍后会讲)。
3. rvalue：right value,即我们所说的右值。

区分表达式为左值表达式还是右值表达式有一个简便的方法：如果刻意对表达式使用&取值，那么它就是一个左值表达式，如果不可以，那么它就是一个右值表达式。TODO：xvalue能否使用&取值。

    int a;
    int b;
    a+b;
    "1";
    ++a;
    a++;

以上表达式中，int a, int b, ++a是左值, a+b, "1", a++是右值。

函数调用根据返回值的不同可以分是lvalue，xvluae，rvalue。

    int& add (int a, int b) {
          int c = a+b;
          return c;
    }

    int&& add(int a, int b) {
          int&& d = a+b;
          return d;
    }

    int add (int a, int b) {
    	  return a+b;
    }


1. 如果函数调用返回一个左值引用，那么函数的结果就是一个lvalue。
2. 如果函数调用返回一个右值引用，那么函数的结果就是一个xvalue。
3. 如果函数调用返回一个非引用，那么函数的结果就是一个rvalue。

# 左值引用与右值引用

左值引用分为常量左值引用与非常量左值引用，即最常见的引用的用法

    int lvalue = 10;
    const int constLvalue = 10;
    
    //将非常量左值引用绑定到非常量左值上
    int& lref = lvalue;
    
    //常量左值引用可以绑定常量左值与非常量左值
    const int& cnt_lref = lvalue;
    const int& cnt_lref_cnt_lvalue = constLvalue;

在C++11之前，并没有右值引用的概念，但是右值可以被绑定到一个常量左值引用

    //将常量左值引用绑定到一个右值上
    const int& cnt_lref = 1+2;

注意，在此处因该被回收空间的右值表达式因为绑定到常量左值引用的关系，其生命周期被延长了，与常量左值引用的生命周期相同。这有什么好处呢，让我们来看下面的例子。

    class CMyString {
    public:
        CMyString() {
	    str = new char[1];
            str[0] = '\0';
        }

	//CMyString(CMyString& src) {
	//    str = new char[strlen(src.str)+1];
	//    strcpy(str, src.str);
	//}

	CMyString(const CMyString& src) {
	    str = new char[strlen(src.str)+1];
	    strcpy(str, src.str);
	}

	~CMyString() {
	    delete[] str;
	}


    private:
        char* str;
    }

    CMyString getAString() {
        CMystring aRvalueString;
	return aRvalueString;
    }

    int main () {
        CMyString(getAString());
	return 0;
    }

函数getAString返回一个右值，通过将这个右值绑定到一个常量左值引用上，减少了构造函数的开销（当然，这根本不是构造函数要使用引用作为参数的原因，真正的原因是为了构造函数的递归调用）。但是这样写存在一个问题，拷贝构造函数中是常引用，我们并不能构改变其中的值（虽然绝大多数情况下我们并不需要改变其值，但是在如auto_ptr的拷贝构造函数中，我们是需要对传入的参数做改变的)。但是const又不能够作为函数重载的依据，所以要么使用常引用拷贝构造函数，要么放弃使用右值来初始化一个类的方法。

艾玛，我都不想放弃怎么办呢？C++11中引入了右值引用的概念来解决这个问题而且右值引用可以用作函数的重载。那么我们就可以添加如下右值引用拷贝构造函数

   CMyString (CMyString&& src) {
       str = new char[strlen(src.str)+1];
       strcpy(str, src.str);
   }

这样我们就可以即使用右值来初始化一个类又能够在其拷贝构造函数中改变传入的参数的值。



是不是很神奇，是不是很帅，C++11是不是叼的不行！！

什么？你说这个太low！你说这没啥用？哎哎哎，别走啊，下面还有更高达上的内容呢，不信你看看进度条～


其实配合右值引用一起出现的是移动语义，两者结合在一起才是双剑合璧，天下无敌～下面我们先了解什么是移动语义，然后在看两者结合带来的好处。

# 移动语义

让我们再来看一看刚刚那个右值引用做参数的构造函数

    CMyString(CMyString&& src) {
        str = new char[strlen(src.str)+1];
        strcpy(str, src.str);
    }

我们对src.str做了一次深拷贝(deep copy)，主要原因是src是个右值，其空间被分配在栈上，而且在右值引用src生命周期结束后这部分空间要被回收。在数据量不大时，深拷贝似乎没有什么影响，但是当str巨大时，深拷贝是一个非常费时的问题。先将内存完全复制一份，然后将之前的内存再释放掉是一件多么傻的事啊！对，在C++11赋予了抢夺这块内存的权利！对没错，就是抢他丫的，不要深拷贝！那么我们的构造函数就可以这么写

    CMyString(CMyString&& src) {
       str = src.str;
    }

当然，你又不是上帝，C++11也不会允许你能抢所有的内存，所以我们要搞清楚那些内存是C++11允许我们抢夺的。


# move与forward